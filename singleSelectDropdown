import { Component, Input, Output, EventEmitter, OnInit, OnChanges, SimpleChanges, forwardRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { signal, computed } from '@angular/core';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { MatOptionModule } from '@angular/material/core';
import { MatSelectChange } from '@angular/material/select';
import { finalize } from 'rxjs/operators';

import { createControlValueAccessorProviders } from '../abstractions/control-value-accessor-base';
import { ListOfValues } from '../../core/models/list-of-values.model';
import { LovServiceInterface } from '../../core/services/abstractions/lov.service.interface';
import { PreferenceServiceInterface } from '../../core/services/abstractions/preference.interface';
import { OptionInfo } from '../abstractions/option-info'; // optional helper type if you have it

@Component({
  selector: 'app-single-selection-dropdown',
  standalone: true,
  imports: [CommonModule, FormsModule, MatFormFieldModule, MatSelectModule, MatOptionModule],
  templateUrl: './single-selection-dropdown.component.html',
  styleUrls: ['./single-selection-dropdown.component.scss'],
  providers: [
    // provider helper that wires up NG_VALUE_ACCESSOR for you. If you don't have it,
    // replace with the NG_VALUE_ACCESSOR provider you used elsewhere.
    createControlValueAccessorProviders(forwardRef(() => SingleSelectionDropdownComponent))
  ]
})
export class SingleSelectionDropdownComponent<T = ListOfValues> implements OnInit, OnChanges {
  // Inputs
  @Input() label = '';
  @Input() placeholder = 'Select';
  @Input() items: T[] | null = null;            // optional: caller can pass items directly
  @Input() lovType = '';                        // if provided, LOVs will be loaded from service
  @Input() keyProp: keyof T = 'value' as any;   // property used as identifier
  @Input() displayProp: keyof T = 'description' as any; // property used to display
  @Input() hasAll = false;
  @Input() moduleName = '';
  @Input() type = '';                           // used for preferences key

  // Outputs
  @Output() selectionChange = new EventEmitter<T | null>();
  @Output() selectedItemChange = new EventEmitter<T | null>();

  // internal reactive state using signals
  sourceItems = signal<T[]>([]);
  selected = signal<T | null>(null);
  isLoading = signal(false);
  disabled = signal(false);

  // computed display for template convenience
  displayValue = computed(() => {
    const s = this.selected();
    return s ? String((s as any)[this.displayProp]) : '';
  });

  // ControlValueAccessor callbacks (set by registerOnChange / registerOnTouched)
  private onChange: (v: any) => void = () => {};
  private onTouched: () => void = () => {};

  constructor(
    private readonly lovService: LovServiceInterface,
    private readonly preferences: PreferenceServiceInterface
  ) {}

  ngOnInit(): void {
    // if items were passed directly, use them; otherwise attempt load if lovType set
    if (this.items && this.items.length > 0) {
      this.sourceItems.set(this.items);
      this.setupPreferences();
    } else if (this.lovType) {
      this.loadLovData();
    } else {
      // still try to setup preferences so default picks can apply
      this.setupPreferences();
    }

    // subscribe to preferences reset event if your service exposes one (optional)
    if ((this.preferences as any).preferencesResetContextDatas && (this.preferences as any).preferencesResetContextDatas.subscribe) {
      (this.preferences as any).preferencesResetContextDatas.subscribe(() => this.setupPreferences());
    }
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['items'] && this.items) {
      this.sourceItems.set(this.items);
      this.setupPreferences();
    }
    if (changes['lovType'] && !changes['lovType'].firstChange) {
      // reload lovs if lovType changed
      if (this.lovType) {
        this.loadLovData();
      }
    }
  }

  // --- ControlValueAccessor methods (writeValue/registerOnChange/registerOnTouched/setDisabledState) ---
  writeValue(obj: any): void {
    // obj may be an identifier or the object itself. We support both:
    if (obj == null) {
      this.selected.set(null);
      return;
    }

    // if items are already loaded, find item by keyProp; otherwise store and wait for items
    const items = this.sourceItems();
    if (items && items.length > 0) {
      const found = this.findItemFromValue(obj);
      this.selected.set(found ?? null);
    } else {
      // temporarily set as-is (caller may pass object)
      this.selected.set(obj as T);
    }
  }

  registerOnChange(fn: any): void { this.onChange = fn; }
  registerOnTouched(fn: any): void { this.onTouched = fn; }
  setDisabledState(isDisabled: boolean): void { this.disabled.set(isDisabled); }

  // --- user interaction handler used in template ---
  onSelectionChange(value: T | null): void {
    this.selected.set(value);
    // persist preference (if moduleName/type provided)
    if (value && this.moduleName && this.type && (this.preferences?.setPreference)) {
      const prefKey = this.getCombinedModuleNameAndType();
      // if your items are ListOfValues, persist value or orderBy as needed:
      try {
        (this.preferences as any).setPreference(prefKey, (value as any).value ?? (value as any).orderBy ?? value);
      } catch {
        // ignore if preferences service shaped differently
      }
    }

    // inform Angular forms and parent
    this.onChange(value);
    this.onTouched();
    this.selectionChange.emit(value);
    this.selectedItemChange.emit(value);
  }

  // --- helper: find item matching incoming value (by keyProp or by entire object) ---
  private findItemFromValue(incoming: any): T | undefined {
    const items = this.sourceItems();
    if (!items || items.length === 0) return undefined;

    // if incoming is object, try to match by keyProp or object equality
    if (typeof incoming === 'object' && incoming !== null) {
      return items.find(it => (it as any) === incoming || (it as any)[this.keyProp] === (incoming as any)[this.keyProp]);
    }

    // primitive incoming => match by keyProp or value property
    return items.find(it => (it as any)[this.keyProp] === incoming || (it as any).value === incoming);
  }

  // --- load LOVs from service ---
  private loadLovData(): void {
    if (!this.lovType) return;
    // guard: avoid double load if already have items
    if (this.sourceItems().length > 0) {
      this.setupPreferences();
      return;
    }

    this.isLoading.set(true);
    this.lovService.getLovData(this.lovType())
      .pipe(finalize(() => this.isLoading.set(false)))
      .subscribe({
        next: (data: ListOfValues[]) => {
          let items = data as unknown as T[];
          if (this.hasAll) {
            // insert an "All" option at the first position (shape depends on ListOfValues)
            const allOption = { type: 'DEFAULT', value: '', description: 'All', orderBy: 0 } as unknown as T;
            items = [allOption, ...items];
          }
          this.sourceItems.set(items);
          this.setupPreferences();
        },
        error: () => {
          // swallow or log - up to you
        }
      });
  }

  // --- read preference and set selection if available ---
  private setupPreferences(): void {
    if (!this.moduleName || !this.type || !this.preferences) return;

    try {
      const prefKey = this.getCombinedModuleNameAndType();
      const prefVal = (this.preferences as any).getPreferencebyKey?.(prefKey);
      if (prefVal == null) return;

      // find matching item in sourceItems
      const sel = this.sourceItems().find(it => {
        const itAsAny = it as any;
        // try orderBy then value
        if (itAsAny.orderBy != null && itAsAny.orderBy === prefVal) return true;
        if (itAsAny.value != null && itAsAny.value === prefVal) return true;
        if (itAsAny[this.keyProp] != null && itAsAny[this.keyProp] === prefVal) return true;
        return false;
      });

      if (sel) {
        this.selected.set(sel);
        this.onChange(sel);
      }
    } catch {
      // ignore if preferences service different
    }
  }

  // combine module + type into preference key format
  private getCombinedModuleNameAndType(): string {
    return `${this.moduleName}.${this.type}`;
  }
}

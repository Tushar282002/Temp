Here's the complete solution with mat-select instead of chips:
1. Updated Employee Multi-Select Component (TypeScript)
employee-multi-select-search.component.ts
import { NgIf } from '@angular/common';
import { Component, Input, ViewEncapsulation, signal, ViewChild, ElementRef, Output, EventEmitter } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatSelectModule, MatSelect } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatOptionModule } from '@angular/material/core';
import { MatTooltipModule } from '@angular/material/tooltip';
import { SearchAutoCompleteComponent } from '../abstractions/search-autocomplete.component';
import { createControlValueAccessorProviders } from '../abstractions/control-value-accessor-base';
import { OptionInfo } from '../abstractions/options-parent-base';

@Component({
  selector: 'app-employee-multi-select-search',
  standalone: true,
  imports: [
    MatSelectModule,
    MatFormFieldModule,
    MatOptionModule,
    MatCheckboxModule,
    NgIf,
    FormsModule,
    ReactiveFormsModule,
    MatTooltipModule
  ],
  templateUrl: './employee-multi-select-search.component.html',
  styleUrls: ['./employee-multi-select-search.component.scss'],
  encapsulation: ViewEncapsulation.None,
  providers: createControlValueAccessorProviders(EmployeeMultiSelectSearchComponent)
})
export class EmployeeMultiSelectSearchComponent<T> extends SearchAutoCompleteComponent<T> {
  
  @ViewChild('searchInput') searchInputElement?: ElementRef<HTMLInputElement>;
  @ViewChild('matSelectRef') matSelectRef?: MatSelect;
  
  //#region Input Properties
  
  /**
   * Callback to add initial items when component loads
   */
  @Input() addInitialItemsCallback?: () => T[];
  
  /**
   * Display format for items - use property names from your employee object
   */
  @Input() override displayMemberPath = '{fullName} ({emailAddress})';
  
  /**
   * Placeholder text for the search input
   */
  @Input() override inputPlaceholder: string = 'Search employees...';
  
  /**
   * Message to show when no results are found
   */
  @Input() noResultsMessage: string = 'No results found in Employee Directory';
  
  //#endregion
  
  //#region Output Events
  
  /**
   * Event emitted when an option is selected (for adding to grid)
   */
  @Output() optionAdded = new EventEmitter<T>();
  
  //#endregion
  
  //#region Lifecycle Hooks
  
  override ngOnInit(): void {
    super.ngOnInit();
  }
  
  ngAfterViewInit(): void {
    setTimeout(() => {
      this.filteredOptions.set([]);
      if (this.searchInputElement) {
        this.searchInputElement.nativeElement.value = '';
      }
    }, 0);
    
    if (this.addInitialItemsCallback) {
      const initialItems = this.addInitialItemsCallback().map(
        result => new OptionInfo(result, this.getViewValue(result))
      );
      this.selectedItemsInternal.set(initialItems);
      this.onChange(this.selectedItems());
    }
  }
  
  //#endregion
  
  //#region Selection Methods
  
  /**
   * Handle checkbox selection change
   */
  onSelectionChange(option: OptionInfo<T>, isSelected: boolean): void {
    if (isSelected) {
      // Add to selected items
      const currentItems = this.selectedItemsInternal();
      this.selectedItemsInternal.set([...currentItems, option]);
      this.onChange(this.selectedItems());
      
      // Emit event to add to grid
      this.optionAdded.emit(option.originalObject);
    } else {
      // Remove from selected items
      this.removeSelectedItemInternal(option);
    }
  }
  
  /**
   * Internal method to remove a selected item
   */
  private removeSelectedItemInternal(item: OptionInfo<T>): void {
    const currentItems = this.selectedItemsInternal();
    const filteredItems = currentItems.filter(
      i => i.objectAsString !== item.objectAsString
    );
    this.selectedItemsInternal.set(filteredItems);
    this.onChange(this.selectedItems());
  }
  
  /**
   * Check if an option is currently selected
   */
  isOptionSelected(option: OptionInfo<T>): boolean {
    return this.selectedItemsInternal().some(
      item => item.objectAsString === option.objectAsString
    );
  }
  
  //#endregion
  
  //#region Input Handling
  
  /**
   * Handle input changes for search
   */
  onSearchInputChange(event: Event): void {
    const input = event.target as HTMLInputElement;
    const value = input.value.trim();
    
    if (value.length === 0) {
      this.filteredOptions.set([]);
      return;
    }
    
    // Call the search callback
    if (this.searchItemsCallback) {
      this.isSearchInProgress = true;
      this.searchItemsCallback(value).subscribe({
        next: (results: T[]) => {
          const options = results.map(
            result => new OptionInfo(result, this.getViewValue(result))
          );
          this.filteredOptions.set(options);
          this.isSearchInProgress = false;
        },
        error: () => {
          this.isSearchInProgress = false;
          this.filteredOptions.set([]);
        }
      });
    }
  }
  
  /**
   * Handle search icon click
   */
  searchOnClick(): void {
    if (this.matSelectRef) {
      this.matSelectRef.open();
    }
  }
  
  //#endregion
  
  //#region Display Methods
  
  /**
   * Get display value for selected items
   */
  getSelectedDisplayValue(): string {
    const selected = this.selectedItemsInternal();
    if (selected.length === 0) return '';
    if (selected.length === 1) return selected[0].displayValue;
    return `${selected.length} employees selected`;
  }
  
  //#endregion
}
2. Updated HTML Template
employee-multi-select-search.component.html
<div [class]="isInvalid ? 'form-group' : ''">
  <mat-form-field 
    appearance="outline" 
    class="employee-select-container"
    [class]="{
      'is-invalid': (isInvalid && validationType === 2), 
      'soft-is-invalid': (isInvalid && validationType === 1)
    }">
    
    <mat-select 
      #matSelectRef
      multiple
      [placeholder]="inputPlaceholder"
      [disabled]="isDisabled()"
      panelClass="employee-select-panel"
      [value]="selectedItemsInternal()">
      
      <!-- Search Input inside dropdown -->
      <div class="input-group input-search-box" (click)="$event.stopPropagation()">
        <input 
          #searchInput
          type="text" 
          (input)="onSearchInputChange($event)" 
          class="form-control search-input" 
          [placeholder]="inputPlaceholder"
          style="background-color:#FAFDFC;">
        
        <div class="input-group-append">
          <span class="input-group-text no-border-left" title="Search">
            <i *ngIf="isSearchInProgress" class="once-loader once-loader-xs"></i>
            <i *ngIf="!isSearchInProgress" class="icon icon-search"></i>
          </span>
        </div>
      </div>
      
      <!-- Options with checkboxes -->
      <div class="options-container">
        @for (option of filteredOptions(); track option.objectAsString) {
          <mat-option 
            [value]="option"
            (onSelectionChange)="onSelectionChange(option, $event.isUserInput && $event.source.selected)"
            class="employee-option">
            <mat-checkbox 
              [checked]="isOptionSelected(option)"
              (click)="$event.stopPropagation()"
              class="option-checkbox">
              <span 
                class="option-text"
                matTooltipClass="tooltip" 
                [matTooltip]="option.displayValue">
                {{ option.displayValue }}
              </span>
            </mat-checkbox>
          </mat-option>
        }
      </div>
      
      <!-- No Results Message -->
      @if (filteredOptions()?.length === 0 && searchInput?.value && !isSearchInProgress) {
        <mat-option disabled class="no-results-option">
          {{ noResultsMessage }}
        </mat-option>
      }
    </mat-select>
  </mat-form-field>

  <!-- Validation Error Message -->
  <div 
    *ngIf="isInvalid && showValidationMessage"
    [class]="{
      'crm-form-error-feedback': (isInvalid && validationType === 2), 
      'soft-invalid-feedback': (isInvalid && validationType === 1)
    }">
    <i class="icon icon-error"></i>
    {{ errorMessage }}
  </div>
</div>
3. Updated CSS
employee-multi-select-search.component.scss
.employee-select-container {
  width: 50%; // Reduced width - not till end of page
  min-width: 300px;
  max-width: 600px;
  
  ::ng-deep {
    .mat-mdc-text-field-wrapper {
      padding: 0;
    }
    
    .mat-mdc-form-field-flex {
      align-items: center;
    }
    
    .mat-mdc-form-field-infix {
      padding: 12px 0;
      min-height: 48px;
      border: 0;
    }
  }
}

// Search input inside dropdown
.input-search-box {
  padding: 8px 12px;
  border-bottom: 1px solid #e0e0e0;
  background: #fff;
  position: sticky;
  top: 0;
  z-index: 10;
  
  .search-input {
    border: 1px solid #ced4da;
    border-right: none;
    height: 36px;
    font-size: 14px;
    
    &:focus {
      border-color: #80bdff;
      outline: 0;
      box-shadow: none;
    }
  }
  
  .input-group-append {
    .input-group-text {
      background-color: #fff;
      border: 1px solid #ced4da;
      border-left: none;
      height: 36px;
      cursor: pointer;
      
      &.no-border-left {
        border-left: 1px solid #ced4da;
      }
    }
  }
}

// Options container
.options-container {
  max-height: 300px;
  overflow-y: auto;
}

// Individual options styling
::ng-deep {
  .employee-select-panel {
    .employee-option {
      padding: 0 !important;
      height: auto !important;
      min-height: 40px !important; // Reduced from default
      line-height: normal !important;
      
      .mdc-list-item__primary-text {
        width: 100%;
        overflow: visible !important;
      }
      
      .option-checkbox {
        width: 100%;
        padding: 8px 16px; // Reduced padding
        margin: 0;
        display: flex;
        align-items: center;
        
        .mdc-checkbox {
          margin-right: 12px;
          flex-shrink: 0;
        }
        
        .option-text {
          flex: 1;
          font-size: 14px;
          line-height: 1.4;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
        }
        
        .mdc-label {
          width: 100%;
          cursor: pointer;
        }
      }
      
      &:hover {
        background-color: rgba(0, 0, 0, 0.04);
      }
      
      &.mat-mdc-option-active {
        background-color: rgba(0, 0, 0, 0.04);
      }
    }
    
    .no-results-option {
      padding: 12px 16px !important;
      color: #666;
      font-style: italic;
      font-size: 14px;
      text-align: center;
      min-height: 40px !important;
    }
  }
}

// Validation styles
.is-invalid {
  ::ng-deep {
    .mat-mdc-form-field-outline {
      .mdc-notched-outline__leading,
      .mdc-notched-outline__notch,
      .mdc-notched-outline__trailing {
        border-color: #dc3545 !important;
        border-width: 2px !important;
      }
    }
  }
}

.soft-is-invalid {
  ::ng-deep {
    .mat-mdc-form-field-outline {
      .mdc-notched-outline__leading,
      .mdc-notched-outline__notch,
      .mdc-notched-outline__trailing {
        border-color: #ffc107 !important;
        border-width: 2px !important;
      }
    }
  }
}

.crm-form-error-feedback {
  color: #dc3545;
  font-size: 0.875rem;
  margin-top: 0.25rem;
  display: flex;
  align-items: center;
  
  i {
    margin-right: 4px;
  }
}

.soft-invalid-feedback {
  color: #ffc107;
  font-size: 0.875rem;
  margin-top: 0.25rem;
  display: flex;
  align-items: center;
  
  i {
    margin-right: 4px;
  }
}

.tooltip {
  font-size: 12px;
  max-width: 300px;
}
4. Updated Visibility Component
opportunity-visibility.component.ts
export class OpportunityVisibilityComponent {
  
  private readonly employeeService = inject(EmployeeService);
  private readonly userService = inject(UserService);
  private readonly permissionService = inject(PermissionService);
  private readonly opportunityReadService = inject(OpportunityReadService);
  private readonly dialogRef = inject(MatDialogRef<OpportunityVisibilityComponent>);

  colDefs: ColDef[] = [
    { field: nameof<IAccessList>("employeeName"), headerName: 'NAME' },
    { field: nameof<IAccessList>("teamName"), headerName: "TEAM NAME" },
    { field: nameof<IAccessList>("visibilityRules"), headerName: "VISIBILITY RULES" },
    { field: nameof<IAccessList>("addedBy"), headerName: "ADDED BY" },
    {
      field: nameof<IAccessList>("isManuallyAdded"),
      sort: 'desc',
      suppressHeaderFilterButton: false,
      headerComponentParams: {
        innerHeaderComponent: AgGridIconHeaderTemplate,
        innerHeaderComponentParams: { iconName: "bin-outline", isSvg: true }
      },
      cellClass: 'text-center',
      cellRendererSelector: (cellParams: ICellRendererParams<IAccessList, boolean, any>) => cellParams.value ? {
        component: AgGridCellButtonTemplate,
        params: {
          iconName: "icon-close",
          style: 'fw-bold fs-1 danger',
          onClick: (rowData: IAccessList) => this.deleteRow(rowData)
        }
      } : undefined
    }
  ];

  rowData = signal<IAccessList[]>([]);
  bnpTheme = agGridTheme();
  activeBusinessLine = getBusinessAreaName(this.permissionService.activeBusinessArea);
  opportunityType = "";
  privacyLevel = "";
  visibilityMessage = '';

  ngOnInit(): void {
    this.opportunityReadService.opportunityObservable.subscribe((opportunity: IOpportunityModel) => {
      this.opportunityType = opportunity.opportunityType ?? "";
      this.privacyLevel = opportunity.privacyLevel ?? "";
      this.visibilityMessage = this.buildVisibilityMessage();
    });
  }

  /**
   * Handle when employee is selected from dropdown - Add to grid
   */
  onEmployeeAdded(employee: IBnppParticipant): void {
    const currentData = this.rowData();
    
    // Check if employee already exists in grid
    const exists = currentData.some(item => item.employeeId === employee.employeeId);
    if (exists) {
      console.log('Employee already added to the list');
      return;
    }
    
    // Create new access list entry
    const newEntry: IAccessList = {
      id: this.generateTempId(), // Generate temporary ID
      employeeName: employee.fullName,
      emailAddress: employee.emailAddress,
      employeeId: employee.employeeId,
      teamName: '', // You can add team info if available
      visibilityRules: 'Manually Added',
      addedBy: this.userService.context?.firstName + ' ' + this.userService.context?.lastName,
      isManuallyAdded: true
    };
    
    // Add to grid
    this.rowData.set([...currentData, newEntry]);
  }

  /**
   * Generate temporary ID for new entries
   */
  private generateTempId(): string {
    return 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  private deleteRow(accessToRemove?: IAccessList): void {
    if (!accessToRemove?.id) {
      return;
    }
    const newArray = this.rowData().filter(al => al.id !== accessToRemove?.id);
    this.rowData.set(newArray);
  }

  protected closeDialog(): void {
    this.dialogRef.close(false);
  }

  protected saveList(): void {
    // Get only manually added users
    const manuallyAddedUsers = this.rowData().filter(item => item.isManuallyAdded);
    
    // Save logic here
    console.log('Saving list:', manuallyAddedUsers);
    
    this.dialogRef.close(true);
  }

  protected onGridReady(): void {
    this.opportunityReadService.GetOpportunityVisibilityList()
      .subscribe(result => {
        this.rowData.set(result);
      });
  }

  private buildVisibilityMessage(): string {
    console.log('visibility component receives', this.opportunityType, this.privacyLevel, this.activeBusinessLine);
    let visibilityMessage = '';
    
    if (this.activeBusinessLine === 'EQD') {
      const key = `${this.activeBusinessLine}${this.opportunityType}${this.privacyLevel}`;
      visibilityMessage = (GlobalConstants as Record<string, string>)[key] ?? 'visibility message not found';
    } else {
      visibilityMessage = `This opportunity has been saved with a <b>${this.privacyLevel}</b> privacy level. The users that have visibility to this opportunity are: <br>`;
      
      if (this.privacyLevel === 'Normal' || this.privacyLevel === 'Sensitive') {
        const normalSensitiveText = (GlobalConstants as Record<string, string>)['NormalSensitive'];
        visibilityMessage += normalSensitiveText;
      } else if (this.privacyLevel === 'Privileged') {
        const privilegedText = (GlobalConstants as Record<string, string>)['Privileged'];
        visibilityMessage += privilegedText;
      }
    }
    
    console.log('visibility message:', visibilityMessage);
    return visibilityMessage;
  }

  searchEmployeesForVisibility(searchTerm: string): Observable<IBnppParticipant[]> {
    return this.employeeService.searchEmployeesForVisibility(searchTerm);
  }

  addCurrentUserAsParticipant(): IBnppParticipant[] {
    return [];
    // Don't pre-populate current user - let them search and add manually
  }

  closePage(): void {
    this.dialogRef.close();
  }
}
5. Updated HTML for Visibility Component
opportunity-visibility.component.html
<div class="d-flex flex-column visibility-container">
  <div class="custom-header px-3 d-flex justify-content-between">
    <span>Opportunity Visibility</span>
    <button class="btn btn-link-secondary" (click)="closePage()">
      <i class="icon icon-close"></i>
    </button>
  </div>

  <!--popup content -->
  <div class="p-3 flex-grow-1 d-flex flex-column">
    <p class="h5 fw-bold">
      Visibility Guidelines
    </p>
    <p [innerHTML]="visibilityMessage"></p>

    <div class="form-row">
      <div class="col-12">
        <app-employee-multi-select-search
          id="BnppParticipants"
          [searchItemsCallback]="searchEmployeesForVisibility.bind(this)"
          [addInitialItemsCallback]="addCurrentUserAsParticipant.bind(this)"
          (optionAdded)="onEmployeeAdded($event)"
          inputPlaceholder="Search for an Employee to add to the list"
          displayMemberPath="{fullName} ({emailAddress})"
          noResultsMessage="No results found in Employee Directory">
        </app-employee-multi-select-search>
      </div>
    </div>

    <ag-grid-angular 
      class="flex-grow-1 mt-3" 
      [autosizeStrategy]="{type: 'fitGridWidth', columnLimits: [{colId: 'isManuallyAdded', minWidth:90, maxWidth:100}]}"
      [columnDefs]="colDefs" 
      [rowData]="rowData()" 
      (gridReady)="onGridReady()" 
      [theme]="bnpTheme">
    </ag-grid-angular>
  </div>

  <div class="d-flex justify-content-end p-3">
    <button class="btn btn-outline-primary font-weight-bold" (click)="closeDialog()">Cancel</button>
    <button class="ml-2 btn btn-primary font-weight-bold" (click)="saveList()">Save</button>
  </div>
</div>
Key Changes:
âœ… Replaced chips with mat-select - Using Material Select with multiple selection
âœ… Reduced option padding - Options now have compact 8px padding
âœ… Reduced component width - Set to 50% width, not full page width
âœ… Checkbox adds to grid - optionAdded event emits selected employee
âœ… Prevents duplicates - Checks if employee already exists before adding
âœ… No CRMDEV4 showing - Removed pre-population by returning empty array
âœ… Search inside dropdown - Search box appears at top of dropdown panel
âœ… Compact design - Minimized heights and padding throughout
Now when you check an option, it immediately adds to the grid! ðŸŽ‰
